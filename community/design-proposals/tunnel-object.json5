{
  // spec defines the specifications of the tunnel such as the destination network ID,
  // the ttl, or the target address
  spec: {
    // the tunnel information is generated at the time the tunnel is requested
    tunnel: {
      // generated by the server and used for attaching other data from other collections
      // or tables to this tunnel such as access log information
      id: "...",
      // the goal of access is to provide information to the server handling the new
      // tunnel to determine how the tunnel should be exposed, i.e. should it create
      // a listener that's exposed to the public, or should it create a reverse proxy
      // that is only accessible to certain internal services.
      access: {
        // specified by the user, indicates whether the server should set up a
        // listener for an exposed URL, for example device1.example.com
        endpoint: true,
        // specified by the server depending on how this tunnel was created, if
        // the tunnel was created by a server-side dca, then we'd expose an internal
        // route for accessing the tunnel
        internal: true,
      },
      // ttl determines how long the server should allow this tunnel ID to be open
      ttl: "30m",
    },
    // describes information about the device on the agent's network that we intend
    // to tunnel traffic to/from. I'm trying to decide if this should be an array or
    // not. I suppose this depends largely on whether we can multiplex connections over
    // a single tunnel, or if we can only multiplex tunnels over a single TCP
    // connection. The downside to supporting multiple targets per tunnel object is
    // that it does not allow for load-balancing tunnels for targets between multiple
    // agents.
    target: {
      // the name is used when the server set's up an endpoint for this device if an
      // endpoint is enabled
      name: "device1",
      // the IP address that the agent will act as a reverse proxy for
      address: "10.0.0.1",
      // provides information about the network that we'll be tunneling to
      network: {
        // the id of the network, this id is provided when an agent registers itself.
        // This allows us to not know the specific agent that will open the tunnel (HA
        // configuration). Agents could potentially communicate with each-other using
        // SERF to determine if they should share a network ID? Thinking out loud here
        id: "..."
      }
    },
  },
  // status defines the state of the tunnel as reported by the agents, or the server (in
  // the case of server leases)
  status: {
    // allows multiple servers and agents to be candidates for facilitating a tunnel
    lease: {
      // server lease indicates which server an agent is currently tunneling this tunnel
      // through, it will be used when resolving requests from a 3rd party, into the tunnel
      server: {
        // a self-assigned ID of the server, by the server
        id: "...",
        // determines when the lease expires and can be picked up by another server, maybe
        // we don't need an expiration-based lease here considering that an agent has to
        // contact a single server which means whatever server gets the tunnel.id owns the
        // lease.
        expiration: "...",
      },
      // agent leases allow multiple agents on a single network to coordinate tunneling,
      // this is useful for (1) load-balancing tunnels between multiple agents in case we're
      // opening up 100-200 tunnels like we would during a remote data collection process,
      // and (2) provides redundancy for when an agent may go down, for example agent 1
      // is installed on a client machine that gets shut down over the weekend, whereas
      // agent 2 is installed on a client machine that stays on over the weekend but gets
      // shut down at night. That might be over-engineering but it seems useful and not too
      // difficult.
      agent: {
        // the id is a self assigned id when an agent is registered
        id: "...",
        // the expiration of the agents lease. All agents for a given network ID will have
        // access to all tunnels for that network ID. Agents would use leases to coordinate
        // who should handle the tunnel. If a tunnel exists for a different agent ID but the
        // lease has expired, then a new agent will acquire the lease and attempt to open the
        // tunnel, the server should close the previous tunnel (if it exists) and open the
        // new tunnel.
        expiration: "",
      }
    },
    // connections provides information about all the 3rd parties that made a connection
    // through this tunnel
    connections: [{
      remote: {
        // the remote address that connected to this tunnel
        address: "10.0.0.0"
      }
    }],
    // created indicates when this tunnel object was created
    created: "...",
    // started indicates when this tunnel was last started by an agent
    started: "...",
    // closed indicates when this tunnel was closed
    closed: "...",
  },
}
